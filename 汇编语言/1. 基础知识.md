# 1. 基础知识&寄存器



## 机器语言

机器语言是**机器指令**的集合。

> 机器指令：一台机器可以正确执行的命令 。电子计算机的机器指令是一串**二进制数字**，计算机将其转换为一列**高低电平**，以使计算机的电子器件受到驱动，进行运算。

现在我们常用的 PC机中有一个芯片来执行上述计算机的功能，它叫 cpu `(Central Processing Unit 中央处理单元)`，是一种微处理器。每种微处理器由于**硬件设计和内部结构的不同**，需要不同的电平脉冲来控制，所以每种微处理器都有自己的机器指令集（机器语言）



## 汇编语言的产生，组成

显然机器语言太麻烦了，所以**汇编语言**产生了。eg：

```ass
操作：寄存器BX的内容送到AX中
机器指令： 1000100111011000
汇编指令： mov ax,bx
```

> 寄存器：简单地说是CPU中可以存储数据的器件，一个CPU中有多个。AX，BX是其中寄存器的代号。

计算器只能读懂机器指令，所以就有**编译器**将汇编指令翻译为机器指令

汇编语言有以下三类指令组成：

1. 汇编指令： 机器码的助记符，有对应的机器码。**（核心）**
2. 伪指令： 无对应机器码，由编译器执行，计算机不执行。
3. 其他符号：如`+, -, *, /`等，由编译器识别，无对应机器码。



## CPU 对数据的读写

CPU 想进行数据的读写，必须和外部器件进行以下三类信息的交互：

1. 存储单元的地址（地址信息）

   > 一个存储单元可以存储8个bit，即8位二进制数

2. 器件的选择，读或写的命令（控制信息）

3. 读或写的数据（数据信息）

这些信息都是**电信号**，要通过**导线**传送。计算机中专门连接 CPU 和其他芯片的导线通常被称为**总线**（是一根根导线的集合。分为地址总线、控制总线、数据总线三类）。



### 地址总线

CPU 通过地址总线来指定存储器单元，可见地址总线上能传送多少不同信息CPU就能对多少个地址单元进行寻址。

一根导线可以传送的稳定状态只有高电平、低电平两种，即1或0。一个CPU有10根地址线，可以传输10位二进制数据（0 ~ 1023），所以该CPU最多可以寻找1024个内存单元。

综上，一个CPU有N根地址线，则它的地址总线**宽度**为N，最多可以寻找`2^n`个内存单元。

#### 寻址能力

- 一个 CPU 地址总线宽度为13，则其可以对 **2^13^** 个**地址单元**进行寻址，每个地址单元可以存储 **`8bit(1 byte)`**，那么该 CPU 的**寻址能力**为 2^13^ byte，即 8KB。



### 数据总线

CPU与内存或其它器件之间的数据传送通过数据总线进行。数据总线的宽度决定CPU与外界的数据传送速度。8根数据线一次可以传送一个8位二进制数据（8bit，1byte~字节~）。所以数据总线宽度为8的CPU传一个2byte的数据得传两次。



### 控制总线

CPU对外部器件的控制通过控制总线（总称，是不同控制线的集合）进行。有多少根控制线，就意味着CPU提供了对外部器件的多少种控制。所以控制总线的宽度决定了CPU对外部器件的**控制能力**



## 存储器芯片

可分为两类：

- 随机存储器（RAM）：可读可写，但必须带电存储，关机后存储的内容丢失。
- 只读存储器（ROM）：只可读取不能写入，关机后内容不丢失。

 

# 寄存器

寄存器是 CPU 中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对 CPU的控制。



## 通用寄存器

**8086CPU**是16位CPU，它的寄存器都是16位的。AX，BX，CX，DX这四个寄存器通常用来存放一般性的数据，被称为**通用寄存器**。

16位寄存器可以存放两个字节，为了跟之前的8位寄存器**兼容**（使得原来基于8位CPU编写的程序稍加修改就可以在16位CPU上运行），AX，BX，CX，DX每个都可以分为两个可以独立使用的8位寄存器来使用。

> AX可分为 AH和AL，BX分为BH，BL......

**字**（word）由两个字节组成， 这两个字节分别称为这个字的**高位字节**和**低位字节**。一个字很自然的可以存放在16位寄存器中，当存放在AX中时，显然AH存放着这个字的高8位，AL存放着低8位。



## mov和add指令

| 汇编指令    | 控制CPU完成的操作 | 用高级语言的语法描述 |
| ----------- | ----------------- | -------------------- |
| `mov ax,18` | 将18送入寄存器AX  | `AX = 18`            |
|  `mov ah,78`  |  将78送入寄存器AH | `AH = 78` |
| `add ax,8` | 将寄存器AX中的数值加上8  |`AX = AX + 8`| 
|`mov ax,bx` |  将寄存器BX中的数据送入寄存器AX| `AX = BX`|
|`add ax,bx` | 将AX和BX中的数值相加，结果存在AX中|`AX = AX + BX`|



- 在16位寄存器AX（储存的值为8226H）中，进行`add ax, 8226H`操作后AX中数据变成多少？

  > `8226H + 8226H = 1044CH`,但16位寄存器只能储存 4位16进制数据（Why？16位寄存器可以存储16位**2进制**数据，**每4位二进制数据才可以表示一位16进制数据**，所以16位寄存器只能存储`16 / 4 = 4`位16进制数据）寄存器中的数据是**从低位依次向高位**存储的，所以1044CH 的1装不下了，==最后AX中的数据为 044C==

在进行数据传送或运算时，指令的两个操作对象的位数应当一致。 





## 8086CPU给出物理地址的方法

8086CPU有20位地址总线，可以传送20位地址，但8086CPU是**16位结构**，内部**一次性处理，传输，暂时存储的地址为16位**，只能送出16位的地址，这怎么办呢？

CPU的相关部件提供两个地址，一个**段地址**，一个**偏移地址**，它们进入地址加法器这个部件中，`段地址 * 16 + 偏移地址 = 物理地址`



## 段寄存器

8086CPU中段地址在段寄存器中存放，8086CPU有四个段寄存器：CS，DS，SS，ES。我们先只看CS。



## CS & IP

CS 和 IP 是8086CPU中两个最关键的寄存器。**它们指示了CPU当前要读取指令的地址**

我们知道，在内存中，指令和数据没有任何区别，那CPU怎么区分呢？**CPU将CS和IP指向的内存中的内容看作指令**。

程序员能用指令读写的部件只有寄存器。`mov`可以修改AX，BX之类的值，但不能设置CS，IP的值。想改它们，要用**`jmp`**

“jmp 段地址:偏移地址” 可以同时修改 CS，IP的内容。eg： ==**`jmp 2AE3:3`**,执行后CS = 2AE3H，IP = 0003H，CPU将在2AE33H处读取指令==

“jmp 某合法寄存器” 可仅修改IP。eg：==**`jmp ax`** 执行前：ax = 1000H， CS = 2000H， IP = 0003H。-->执行后：ax = 1000H, CS = 2000H, IP = 1000H== 含义上类似于`mov IP, ax`
