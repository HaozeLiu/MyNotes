# Quick Sort 快速排序

## 基本思路 

（分治，递归）

1. **确定分界点**	              首先在数组 `q[ ]` 中确定一个分界点pivot，一般选择 `q[l], q[r] `或` q[(l+r) /2]`;
2. **调整区间**                      让privot**左侧**的数都**小于等于**它，**右侧**的数都**大于等于**它；==难点==
3. **递归处理左右两段**        

最难的部分在于第二步调整区间，下面我们着重讨论这一部分。

## 一个优美的调整区间的方法

让两个指针 i 和 j 分别放到所要调整的部分左侧 l 处与右侧 r 处，分别进行判断，如果 `q [i] < privot`,则 `i ++`（相应的如果 `q [j] > privot`,则 `j --`）；当发现 `q[i] >= privot` 时就停止，同样的判断 `q[j]`, 当 `q [j] <= privot` 时也停止，此时 i ，j 对应的数值都是错误的，交换（swap）i ， j 的值就恰如其分了。交换完后继续进行上述操作，直到 i 和 j 重合。

完成一次调整后，再对调整完的左右两段分别按上面的操作做相同处理，直到 l 与 r 重合。（递归）

##   

## 代码模板

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```





初学算法，我感觉边界问题实在太复杂令人头痛了，暂且先记住模板吧。

